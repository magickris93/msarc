diff --git a/probA/gotoh_input.c b/probA/gotoh_input.c
index 4a5238f..6b4ad68 100644
--- a/probA/gotoh_input.c
+++ b/probA/gotoh_input.c
@@ -8,6 +8,8 @@ char prog_name[10] = "probA";
 
 float BETA=1;            /* default value of BETA */
 float ENDGAP=0;          /* default value of endgaps */
+float OPENGAP=0;         /* default value of gap opening */
+float EXTENDGAP=0;       /* default value of gap extention */
 char MAT_SER[20]="gon";  /* variable stores the selected matrix series */
 			 /* default: gonnet_series */
 float DISTANCE=-1;       /* user can specify a pam distance (gon, pam) or an
@@ -23,6 +25,7 @@ long Nr=1;                /* number of alignments generated by stochastic
 			     option`-calc_s' */
 /* char *track;              stores the alignment encoded as one string of
 			     symbols; option`-calc_s' */
+float CUT=0;             /* stores the cutoff value for sparse output */
 
 
 
@@ -36,6 +39,8 @@ void start(int argc, char **argv)
 {
   int c;
   float Temp;
+  float open;
+  float extend;
   float end;
   float di;
   char buf[20];
@@ -82,6 +87,22 @@ void start(int argc, char **argv)
 	  }
        
 
+	if(strcmp(long_options[option_index].name,"gapopen")==0)
+	  {
+	    if(sscanf(optarg, "%f", &open) != EOF)
+	      {
+		OPENGAP = open;
+	      }
+	  }
+
+	if(strcmp(long_options[option_index].name,"gapextend")==0)
+	  {
+	    if(sscanf(optarg, "%f", &extend) != EOF)
+	      {
+		EXTENDGAP = extend;
+	      }
+	  }
+
 	if(strcmp(long_options[option_index].name,"endgaps")==0)
 	  {
 	    if(sscanf(optarg, "%f", &end) != EOF)
@@ -149,7 +170,7 @@ void start(int argc, char **argv)
   /* Instead of reporting `--verbose'
      and `--brief' as they are encountered,
      we report the final status resulting from them. */
-  if (verbose_flag)
+  if (verbose_flag>0)
     puts ("verbose flag is set");
   
   /* Print any remaining command line arguments (not options). */
@@ -329,6 +350,8 @@ printf("%s - Compute the partition function over all possible alignments between
          "-V, --version    output version information and exit\n"
          "-T               governs relative weight of alignment paths with different scores\n"
 	 "-N               number of alignments generated by stochastic backtracking\n"
+	 "--gapopen        set the score for gap opening, default is based on substitution matrix\n"
+	 "--gapextend      set the score for gap extention, default is based on substitution matrix\n"
 	 "--endgaps        set the score for terminal gaps, default is 0\n"
 	 "--noEg           terminal gaps are treated as gaps inside the alignment\n"
 	 "--noPS           suppress the generation of a dot plot\n"
diff --git a/probA/matrices.c b/probA/matrices.c
index 8459208..35cce4b 100644
--- a/probA/matrices.c
+++ b/probA/matrices.c
@@ -13,7 +13,7 @@ score_m gonnet_init =
 
   LN10/10,                     /* Beta = (ln10)/10  */
 
-  "CSTPAGNDEQHRKMILVFYW",      /* amino acid order */ 
+  "CSTPAGNDEQHRKMILVFYWBXZ",   /* amino acid order */ 
 
   {
    11.5,
@@ -35,7 +35,10 @@ score_m gonnet_init =
     0.0, -1.0,  0.0, -1.8,  0.1, -3.3, -2.2, -2.9, -1.9, -1.5, -2.0, -2.0, -1.7,  1.6,  3.1,  1.8,  3.4,
    -0.8, -2.8, -2.2, -3.8, -2.3, -5.2, -3.1, -4.5, -3.9, -2.6, -0.1, -3.2, -3.3,  1.6,  1.0,  2.0,  0.1,  7.0,
    -0.5, -1.9, -1.9, -3.1, -2.2, -4.0, -1.4, -2.8, -2.7, -1.7,  2.2, -1.8, -2.1, -0.2, -0.7,  0.0, -1.1,  5.1, 7.8,
-   -1.0, -3.3, -3.5, -5.0, -3.6, -4.0, -3.6, -5.2, -4.3, -2.7, -0.8, -1.6, -3.5, -1.0, -1.8, -0.7, -2.6,  3.6, 4.1, 14.2 },
+   -1.0, -3.3, -3.5, -5.0, -3.6, -4.0, -3.6, -5.2, -4.3, -2.7, -0.8, -1.6, -3.5, -1.0, -1.8, -0.7, -2.6,  3.6, 4.1, 14.2,
+    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0,  0.0, 0.0,
+    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0,  0.0, 0.0, 0.0,
+    0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 0.0,  0.0, 0.0, 0.0, 0.0 },
 
   {6.00, 0.80},   /* gap open und extend penalties for an all positive matrix see: J.Mol.Biol.(1995) 249, 816 ff */
 
diff --git a/probA/options.c b/probA/options.c
index c2e0f18..78e9415 100644
--- a/probA/options.c
+++ b/probA/options.c
@@ -8,6 +8,8 @@ int typ_flag=-1;     /* Flag set by `-DNA'=1  or `-prot'=0, default -1,
 int PS_flag=1;       /* Flag set by `-PS', default is 1 =>
 			postscript output */
 
+int Ogap_flag=0;
+int Xgap_flag=0;
 int Egap_flag=1;     /* Flag set by `-endgaps', the default value of endgaps
 		        is 0, but can be modified by the user. To turn off the
 		        endgaps option use -noEg*/
@@ -42,13 +44,15 @@ struct option long_options[] =
   {"version", 0, 0, 'V'},
   /* These options set a flag & have no argument */
   {"verbose", 0, &verbose_flag, 1},
-  {"brief", 0, &verbose_flag, 0},
+  {"brief", 0, &verbose_flag, -1},
   {"DNA", 0, &typ_flag, 1},
   {"prot", 0, &typ_flag, 0},
   {"noEg", 0, &Egap_flag, 0},
   {"noPS", 0, &PS_flag, 0},
   /* These options set a flag & have an argument */
   {"pam", 1, &dist_flag, 1},
+  {"gapopen", 0, &Ogap_flag,1},
+  {"gapextend", 0, &Xgap_flag,1},
   {"endgaps", 1, &Egap_flag,1},
   {"score_matrix", 1, &matrix_flag,1},
   /*{"calc_s", 1, &calcS_flag,1},
diff --git a/probA/pf_goto.c b/probA/pf_goto.c
index 00dcfaa..ae059f5 100644
--- a/probA/pf_goto.c
+++ b/probA/pf_goto.c
@@ -1,5 +1,9 @@
 #include "pfgoto.h"
 
+/* #define NO_SCALE */
+#define NO_ORDER_SEQS
+#define REC_F_INCL_E
+#define REC_E_INCL_F
 
 #define MAX(a,b) (( (a) > (b) ) ? (a) : (b) )
 #define MIN(a,b) (( (a) < (b) ) ? (a) : (b) )
@@ -14,9 +18,10 @@
 static sequ *so; /* array with 2 members (longer seq + name is in so[0]) */
 static iseq *si; /* like '*so' but sequences are encoded as strings of digits
 		    see function code sequence */
-static u_sc scmat; /* scoring matrix */
+u_sc scmat; /* scoring matrix */
 static matrix pmat,rmat; /* partition function and revers pf */
 static real **Pr; /* match probability matrix */
+static real **e_beta_score;
 static int sran=0; /* for initialisation of of the "Mersenne Twister"*/
 static int betaswi=0,stochswi=0;
 static double beta=0;
@@ -38,6 +43,9 @@ aligm add_sequences(sequ *os, aligm a);
 /* determines the length of the longer sequence */
 int length_l(sequ *seq)
 {
+#ifdef NO_ORDER_SEQS
+  return strlen(seq[0].seq);
+#else
   int l0,l1;
 
   l0 = strlen(seq[0].seq);
@@ -51,11 +59,15 @@ int length_l(sequ *seq)
     {
       return(l1);
     }
+#endif
 }
 /*---------------------------------------------------------------------------*/
 /* determines the length of the shorter sequence */
 int length_s(sequ *seq)
 {
+#ifdef NO_ORDER_SEQS
+  return strlen(seq[1].seq);
+#else
   int l0,l1;
 
   l0 = strlen(seq[0].seq);
@@ -69,6 +81,7 @@ int length_s(sequ *seq)
     {
       return(l1);
     }
+#endif
 }
 
 
@@ -420,7 +433,7 @@ aligm align(sequ *seq_array)
   /* case nucleic acid typ_flag=1 */ 
   else if(typ_flag==1)
     {
-      if(MAT_SER[0] != '\0')
+      if(MAT_SER[0] != '\0' && verbose_flag>=0)
 	{
 	  fprintf(stderr,"The input sequences are DNA therefor the program uses the default DNA scoring matrix \n");
 	}
@@ -439,7 +452,7 @@ aligm align(sequ *seq_array)
   alig=add_sequences(so,alig);
 
   /* allocated in init_matseries */ 
-  free(matser);
+  if(typ_flag==0) free(matser);
    
   return(alig);
   
@@ -449,17 +462,18 @@ aligm align(sequ *seq_array)
 /*---------------------------------------------------------------------------*/
 void free_partition_f(real **m, sequ *s)
 {
-  int i, l0, l1;
+  int i, l0, l1, l;
 
   l0=length_l(s);
   l1=length_s(s);
+  l=strlen(scmat.monomers);
 
   /* allocated in prop_alig */
-  for(i=0; i<l0+1; i++)
+  if(m)
     {
-      free(m[i]);
+      free(m[0]);
+      free(m);
     }
-  free(m);
 
    /* allocated in partf */
   
@@ -473,6 +487,12 @@ void free_partition_f(real **m, sequ *s)
   free(pmat.E);
   free(pmat.F);
     
+  for(i=0; i<l; i++)
+    {
+      free(e_beta_score[i]);
+    }
+  free(e_beta_score);
+    
   /* allocated in revers_partf */
   
   for(i=0; i<l1+1; i++)
@@ -586,14 +606,16 @@ u_sc convert_matrix(score_m sm)
   double min;
   int swi;    /* switch between +/- or a all + scoring matrix
 		   swi=0 -> +/- matrix */
+  double go;
+  double ge;
   swi=0;
   
   /* beta stores the original value of BETA */  
-  if(!betaswi)
+  /* if(!betaswi) */
     {
       T=1/BETA;
       beta=BETA;
-      ++betaswi;
+      /* ++betaswi; */
     }
   
   laa=strlen(sm.monomers); /* lenght of the amino_acid_string */
@@ -645,7 +667,7 @@ u_sc convert_matrix(score_m sm)
       
       smat.beta*=beta;   /* BETA = 1/T */
       
-      BETA=smat.beta;    /* => BETA = smat.beta/T */ 
+      /* BETA=smat.beta; */    /* => BETA = smat.beta/T */
       
       strcpy(smat.monomers, sm.monomers);
       
@@ -685,10 +707,12 @@ u_sc convert_matrix(score_m sm)
      k lenght of the gap */
 
   /* open +/- */ 
+      go = -sm.pos.o;
+      if(Ogap_flag) go = OPENGAP;
       j=laa;
       for(i=0; i<laa; i++)
 	{
-	  smat.mat[i][j] = -sm.pos.o;
+	  smat.mat[i][j] = go;
 	}
       
       smat.mat[laa][j]=0.0;
@@ -696,15 +720,17 @@ u_sc convert_matrix(score_m sm)
       i=laa;
       for(j=0; j<laa; j++)
 	{
-	  smat.mat[i][j] = -sm.pos.o;
+	  smat.mat[i][j] = go;
 	}
 
   /* extend +/- */
   
+      ge = -sm.pos.e;
+      if(Xgap_flag) ge = EXTENDGAP;
       j=laa+1;
       for(i=0; i<laa+1; i++)
 	{
-	  smat.mat[i][j] = -sm.pos.e;
+	  smat.mat[i][j] = ge;
 	}
       
       smat.mat[laa+1][j]=0.0;
@@ -712,7 +738,7 @@ u_sc convert_matrix(score_m sm)
       i=laa+1;
       for(j=0; j<laa+1; j++)
 	{
-	  smat.mat[i][j] = -sm.pos.e;
+	  smat.mat[i][j] = ge;
 	}
 
       if(Egap_flag)
@@ -742,7 +768,7 @@ u_sc convert_matrix(score_m sm)
       
       smat.beta*=beta;   /* BETA = 1/T */
       
-      BETA=smat.beta;    /* => BETA = beta/T */ 
+      /* BETA=smat.beta; */    /* => BETA = beta/T */
 
          
       strcpy(smat.monomers, sm.monomers);
@@ -775,10 +801,12 @@ u_sc convert_matrix(score_m sm)
      k lenght of the gap */
 
   /* open +/- */ 
+      go = -sm.p_n.o;
+      if(Ogap_flag) go = OPENGAP;
       j=laa;
       for(i=0; i<laa; i++)
 	{
-	  smat.mat[i][j] = -sm.p_n.o;
+	  smat.mat[i][j] = go;
 	}
       
       smat.mat[laa][j]=0.0;
@@ -786,15 +814,17 @@ u_sc convert_matrix(score_m sm)
       i=laa;
       for(j=0; j<laa; j++)
 	{
-	  smat.mat[i][j] = -sm.p_n.o;
+	  smat.mat[i][j] = go;
 	}
 
   /* extend +/- */
   
+      ge = -sm.p_n.e;
+      if(Xgap_flag) ge = EXTENDGAP;
       j=laa+1;
       for(i=0; i<laa+1; i++)
 	{
-	  smat.mat[i][j] = -sm.p_n.e;
+	  smat.mat[i][j] = ge;
 	}
       
       smat.mat[laa+1][j]=0.0;
@@ -802,7 +832,7 @@ u_sc convert_matrix(score_m sm)
       i=laa+1;
       for(j=0; j<laa+1; j++)
 	{
-	  smat.mat[i][j] = -sm.p_n.e;
+	  smat.mat[i][j] = ge;
 	}
       
       if(Egap_flag)
@@ -1242,8 +1272,10 @@ sequ *sequences(sequ *seq_array)
   sequ *s;
 
 
+#ifndef NO_ORDER_SEQS
   a = (sequ*) calloc(1,sizeof(sequ));
   b = (sequ*) calloc(1,sizeof(sequ));
+#endif
 
   s = (sequ*) calloc(2,sizeof(sequ));
 
@@ -1253,6 +1285,7 @@ sequ *sequences(sequ *seq_array)
   lny=strlen(seq_array[1].name);
   ly=strlen(seq_array[1].seq);
 
+#ifndef NO_ORDER_SEQS
   if(lx >= ly)
     {
       a[0].name=(char*) calloc((lnx+1),sizeof(char));
@@ -1288,16 +1321,24 @@ sequ *sequences(sequ *seq_array)
 
   lny=strlen(b[0].name);
   ly=strlen(b[0].seq);
+#endif
   
   s[0].name=(char*) calloc((lnx+1),sizeof(char));
   s[0].seq=(char*) calloc((lx+1),sizeof(char));
   s[1].name=(char*) calloc((lny+1),sizeof(char));
   s[1].seq=(char*) calloc((ly+1),sizeof(char));
 
+#ifdef NO_ORDER_SEQS
+  strcpy(s[0].name,seq_array[0].name);
+  strcpy(s[0].seq,seq_array[0].seq);
+  strcpy(s[1].name,seq_array[1].name);
+  strcpy(s[1].seq,seq_array[1].seq);
+#else
   strcpy(s[0].name,a[0].name);
   strcpy(s[0].seq,a[0].seq);
   strcpy(s[1].name,b[0].name);
   strcpy(s[1].seq,b[0].seq);
+#endif
 
 
   for(i=0; i<lx; i++)
@@ -1313,6 +1354,7 @@ sequ *sequences(sequ *seq_array)
   /*
     printf("sequences:\n%s\n%s\n\n%s\n%s\n\n",s[0].name,s[0].seq,s[1].name,s[1].seq);     */ 
 
+#ifndef NO_ORDER_SEQS
   free(a[0].name);
   free(a[0].seq);
   free(a);
@@ -1321,6 +1363,7 @@ sequ *sequences(sequ *seq_array)
   free(b[0].name);
   free(b[0].seq);
   free(b);
+#endif
   
   return(s);
 }
@@ -1370,6 +1413,7 @@ aligm align_2(sequ *os, iseq *is, u_sc smat)
              { Fi-1,j-1+match/mismatch;
 
      Ei,j=max{ Mi,j-1+open,
+             { Fi,j-1+open,
              { Ei,j-1+ext;
 
      Fi,j=max{ Mi-1,j+open,
@@ -1378,19 +1422,13 @@ aligm align_2(sequ *os, iseq *is, u_sc smat)
 
   /* initialisation: M    M(0,0) = E0,0 = F0,0 = 0;
                           k = lenght of the gap;
-                          M(0,j>0) = M(i>0,0) = 4*open + 10*(k-1)*ext;(*)
-			  (*) the values are selected in order to avoid the
-			      use of these entries (imagine a kind of "empty"
-			      alignment (e.g. seq1 aligned only to gap
-			      characters), which you simply don't want to
-			      consider (you are looking for the best
-			      alignment in which i and j are paired!)
+                          M(0,j>0) = M(i>0,0) = open + (k-1)*ext;
 
 		     E    E(0,j>0) = open + (k-1)*ext;
-		          E(i>0,0) = 4*open + 10*(k-1)*ext;(*)
+		          E(i>0,0) = open + (k-1)*ext;
 			
 
-		     F    F(0,j>0) = 4*open + 10*(k-1)*ext;(*)
+		     F    F(0,j>0) = open + (k-1)*ext;
 		          F(i>0,0) = open + (k-1)*ext; */
   
 
@@ -1400,23 +1438,23 @@ aligm align_2(sequ *os, iseq *is, u_sc smat)
 
   i=0;
   j=1;
-  m.M[i][j]=m.F[i][j]=4*smat.mat[l-2][s0[0]]; /* 4*Open in s0 */
+  m.M[i][j]=m.F[i][j]=smat.mat[l-2][s0[0]]; /* Open in s0 */
   m.E[i][j]=smat.mat[l-2][s0[0]]; /* Open in s0 */ 
   for(j=2; j< l0+1; j++)
     {
-      /* 10*Extent in s0 */
-     m.M[i][j]=m.F[i][j]=m.M[i][j-1]+10*smat.mat[l-1][s0[j-1]];
+      /* Extent in s0 */
+     m.M[i][j]=m.F[i][j]=m.M[i][j-1]+smat.mat[l-1][s0[j-1]];
      m.E[i][j]=m.E[i][j-1]+smat.mat[l-1][s0[j-1]]; /* Extent in s0 */
     }
   
   i=1;
   j=0;
-  m.M[i][j]= m.E[i][j]=4*smat.mat[l-2][s1[0]]; /* 4*Open in s1 */
+  m.M[i][j]= m.E[i][j]=smat.mat[l-2][s1[0]]; /* Open in s1 */
   m.F[i][j]=smat.mat[l-2][s1[0]]; /* Open in s1 */
   for(i=2; i< l1+1; i++)
     {
-      /* 10*Extent in s1 */
-      m.M[i][j]=m.E[i][j]=m.M[i-1][j]+10*smat.mat[l-1][s1[i-1]];
+      /* Extent in s1 */
+      m.M[i][j]=m.E[i][j]=m.M[i-1][j]+smat.mat[l-1][s1[i-1]];
       m.F[i][j]=m.F[i-1][j]+smat.mat[l-1][s1[i-1]]; /* Extent in s1 */ 
       }
  
@@ -1449,57 +1487,108 @@ aligm align_2(sequ *os, iseq *is, u_sc smat)
 	    {
 	      /* E */
 	      m.E[i][j]=m.M[i][j-1]+smat.endgaps; /*Open in s1 */
+#ifdef REC_E_INCL_F
+	      f=m.F[i][j-1]+smat.endgaps;
+#endif
 	      e=m.E[i][j-1]+smat.endgaps; /* Extent in s1 */
+
+#ifndef REC_E_INCL_F
 	      m.E[i][j]=MAX(m.E[i][j],e);
+#else
+	      max=MAX(m.E[i][j],e);
+	      m.E[i][j]=MAX(max,f);
+	      max=0;
+	      f=0;
+#endif
 	      e=0;
 
 	      /* F */
 	      m.F[i][j]=m.M[i-1][j]+smat.mat[l-2][s0[j-1]]; /* Open in s0 */
+#ifdef REC_F_INCL_E
 	      e=m.E[i-1][j]+smat.mat[l-2][s0[j-1]];
+#endif
 	      f=m.F[i-1][j]+smat.mat[l-1][s0[j-1]]; /* Extent in s0 */
 
+#ifndef REC_F_INCL_E
+	      m.F[i][j]=MAX(m.F[i][j],f);
+#else
 	      max=MAX(m.F[i][j],e);
 	      m.F[i][j]=MAX(max,f);
 	      max=0;
 	      e=0;
+#endif
 	      f=0;
 	    }
 	  else if(Egap_flag && j == l0 && i < l1)
 	    {
 	      /* F */
 	      m.F[i][j]=m.M[i-1][j]+smat.endgaps; /*Open in s0 */
+#ifdef REC_F_INCL_E
 	      e=m.E[i-1][j]+smat.endgaps;
+#endif
 	      f=m.F[i-1][j]+smat.endgaps; /* Extent in s0 */
 
+#ifndef REC_F_INCL_E
+	      m.F[i][j]=MAX(m.F[i][j],f);
+#else
 	      max=MAX(m.F[i][j],e);
 	      m.F[i][j]=MAX(max,f);
 	      max=0;
 	      e=0;
+#endif
 	      f=0;
 
 	      /* E */
 	      m.E[i][j]=m.M[i][j-1]+smat.mat[l-2][s1[i-1]]; /* Open in s1 */
+#ifdef REC_E_INCL_F
+	      f=m.F[i][j-1]+smat.mat[l-2][s1[i-1]];
+#endif
 	      e=m.E[i][j-1]+smat.mat[l-1][s1[i-1]]; /* Extent in s1 */
 
+#ifndef REC_E_INCL_F
 	      m.E[i][j]=MAX(m.E[i][j],e);
+#else
+	      max=MAX(m.E[i][j],e);
+	      m.E[i][j]=MAX(max,f);
+	      max=0;
+	      f=0;
+#endif
 	      e=0;
 	    }
 	  else if(Egap_flag && j == l0 && i == l1)
 	    {
 	      /* F */
 	      m.F[i][j]=m.M[i-1][j]+smat.endgaps; /*Open in s0 */
+#ifdef REC_F_INCL_E
 	      e=m.E[i-1][j]+smat.endgaps;
+#endif
 	      f=m.F[i-1][j]+smat.endgaps; /* Extent in s0 */
+
+#ifndef REC_F_INCL_E
+	      m.F[i][j]=MAX(m.F[i][j],f);
+#else
 	      max=MAX(m.F[i][j],e);
 	      m.F[i][j]=MAX(max,f);
 	      max=0;
 	      e=0;
+#endif
 	      f=0;
 	      	      
 	      /* E */
 	      m.E[i][j]=m.M[i][j-1]+smat.endgaps; /*Open in s1 */
+#ifdef REC_E_INCL_F
+	      f=m.F[i][j-1]+smat.endgaps;
+#endif
 	      e=m.E[i][j-1]+smat.endgaps; /* Extent in s1 */
+
+#ifndef REC_E_INCL_F
 	      m.E[i][j]=MAX(m.E[i][j],e);
+#else
+	      max=MAX(m.E[i][j],e);
+	      m.E[i][j]=MAX(max,f);
+	      max=0;
+	      f=0;
+#endif
 	      e=0;
 	    }
 	  else
@@ -1507,20 +1596,36 @@ aligm align_2(sequ *os, iseq *is, u_sc smat)
 	  
 	      /* E */
 	      m.E[i][j]=m.M[i][j-1]+smat.mat[l-2][s1[i-1]]; /* Open in s1 */
+#ifdef REC_E_INCL_F
+	      f=m.F[i][j-1]+smat.mat[l-2][s1[i-1]];
+#endif
 	      e=m.E[i][j-1]+smat.mat[l-1][s1[i-1]]; /* Extent in s1 */
 
+#ifndef REC_E_INCL_F
 	      m.E[i][j]=MAX(m.E[i][j],e);
+#else
+	      max=MAX(m.E[i][j],e);
+	      m.E[i][j]=MAX(max,f);
+	      max=0;
+	      f=0;
+#endif
 	      e=0;
 	
 	      /* F */
 	      m.F[i][j]=m.M[i-1][j]+smat.mat[l-2][s0[j-1]]; /* Open in s0 */
+#ifdef REC_F_INCL_E
 	      e=m.E[i-1][j]+smat.mat[l-2][s0[j-1]];
+#endif
 	      f=m.F[i-1][j]+smat.mat[l-1][s0[j-1]]; /* Extent in s0 */
 
+#ifndef REC_F_INCL_E
+	      m.F[i][j]=MAX(m.F[i][j],f);
+#else
 	      max=MAX(m.F[i][j],e);
 	      m.F[i][j]=MAX(max,f);
 	      max=0;
 	      e=0;
+#endif
 	      f=0;
 	    }
 
@@ -1796,7 +1901,7 @@ aligm trace_back(matrix m, sequ *os, iseq *is, u_sc smat)
   l1= strlen(os[1].seq);
   
   l=strlen(smat.monomers);
-  la=l0+l1;
+  la=l0+l1+1;
   
   a.a=(char*) calloc((la),sizeof(char));
   M=m.M;
@@ -1854,6 +1959,10 @@ aligm trace_back(matrix m, sequ *os, iseq *is, u_sc smat)
 	  {/* do nothing */}
 	else if (EQUAL(E[i][j], M[i][j-1]+open))
 	  state = Mm;
+#ifdef REC_E_INCL_F
+	else if (EQUAL(E[i][j], F[i][j-1]+open))
+	  state = Ff;
+#endif
 	else {
 	  fprintf(stderr, "Error in backtracking case E\n"); exit(28);
 	}
@@ -1880,8 +1989,10 @@ aligm trace_back(matrix m, sequ *os, iseq *is, u_sc smat)
 	  {/* do nothing */}
 	else if (EQUAL(F[i][j], M[i-1][j]+open))
 	  state = Mm;
+#ifdef REC_F_INCL_E
 	else if (EQUAL(F[i][j], E[i-1][j]+open))
 	  state = Ee;
+#endif
 	else {
 	  fprintf(stderr, "Error in backtracking case F\n"); exit(29);
 	}
@@ -1918,74 +2029,68 @@ real **prop_alig(sequ *os, iseq *is, u_sc m,real **mat,real **revm,aligm a)
   int l1;
   int l0;
   double opt;
-  double s;
-  real **P;
+  double Z;
+  real P;
   real **X;
+  real *Xdata;
+  real **e_beta_score_mul_Z;
+  float BETA;
+
+  BETA=m.beta;
 
   s0=is[0].s;
   s1=is[1].s;
   
   l0=strlen(os[0].seq);
   l1=strlen(os[1].seq);
+  l=strlen(m.monomers);
 
-  /* l1 rows and l0 colums */ 
-  P=(real**) calloc((l1+1),sizeof(real*));
-  for(i=0; i<l1+1; i++)
+  e_beta_score_mul_Z=(real**) calloc(l,sizeof(real*));
+  for(i=0; i<l; i++)
     {
-      P[i]=(real*) calloc((l0+1),sizeof(real));
+      e_beta_score_mul_Z[i]=(real*) calloc(l,sizeof(real));
     }
+
   /* dot plot l0 rows and l1 colums */ 
+  /* Allocate this as a contiguous block of memory to ease it's export Python
+     as a numpy array. */
+  Xdata=(real*) calloc((l0+1)*(l1+1),sizeof(real));
   X=(real**) calloc((l0+1),sizeof(real*));
   for(i=0;i<l0+1;i++){
-  X[i] = (real*) calloc((l1+1),sizeof(real));  
+  X[i] = Xdata + (i*(l1+1));  
   }
 
   /*  printf("prop_alig: %s\n",m.name); */
 
-  P[0][0]=(mat[0][0]/revm[l1][l0])-1;
-
-  P[0][0]=0;
- 
-  opt=a.score;
-
-  /*  printf("opt:%d\n",opt);*/
-  
-  s=2.0*opt/(l0+l1); 
-  s=exp(BETA*s);   /* Fehler beim Skalieren? */
-  
+  Z=mat[0][0];
 
-  for(i=1; i<=l1; i++)
+  for(i=0; i<l; i++)
     {
-      for(j=1; j<=l0; j++)
-	{
-	  double z;
-
-	  z=(m.mat[s0[j-1]][s1[i-1]]);
-	   /* Fehler beim Skalieren? */
-	  P[i][j]=mat[i][j]*revm[i-1][j-1]*s;/* *s */
-	  P[i][j]/=(exp(BETA*z)*mat[0][0]);
-	  /*  P[i][j]*=exp(BETA*s*(i+j)/2);  */
-	}
+      for(j=0; j<l; j++)
+        {
+          e_beta_score_mul_Z[i][j]=e_beta_score[i][j]*Z;
+        }
     }
 
   
-  
-  /*  printf("prop_alig: probs from partion function\n");     */
-/*    print_P(os,P); */
-
-  for(k=i=1; i&&k <=l1; i++,k++)
+  for(i=1; i<=l1; i++)
     {
-      for(l=j=1; j&&l <=l0; j++,l++)
+      for(j=1; j<=l0; j++)
 	{
-	  X[l][k]=P[i][j];
+	  P=mat[i][j]*revm[i-1][j-1];
+	  P/=e_beta_score_mul_Z[s0[j-1]][s1[i-1]];
+	  if(P>=CUT)
+	    {
+	  X[j][i]=P;
+	    }
 	}
     }
   
-  for(i=0; i<l1+1; i++)
+  for(i=0; i<l; i++)
     {
-      free(P[i]);
+      free(e_beta_score_mul_Z[i]);
     }
-  free(P);
+  free(e_beta_score_mul_Z);
   
   return(X);
   
@@ -2002,13 +2107,19 @@ matrix revers_partf(sequ *os, iseq *is, u_sc m, aligm a)
   int l;
   int *s0, *s1;
   double s;
-  double sk; /* scaling factor */ 
+  double sk; /* scaling factor */
   double Zr;
+  double e_beta_open, e_beta_open_0, e_beta_open_1;
+  double e_beta_extend, e_beta_extend_0, e_beta_extend_1;
+  double e_beta_endgap;
   real **rM;
   real **rE;
   real **rF;
+  real *swap;
   matrix pf;
+  float BETA;
  
+  BETA=m.beta;
   l0=strlen(os[0].seq);
   l1=strlen(os[1].seq);
   l=strlen(m.monomers);
@@ -2023,7 +2134,7 @@ matrix revers_partf(sequ *os, iseq *is, u_sc m, aligm a)
      rEi,j = exp(BETA * Open) * (rMi,j-1 + rFi,j-1) +
              exp(BETA * Extend) * (rEi,j-1);
 
-     rFi,j = exp(BETA * Open) * (rMi-1,j) +
+     rFi,j = exp(BETA * Open) * (rMi-1,j + rEi-1,j) +
              exp(BETA * Extend) * (rFi-1,j); */
   
   rM=(real**) calloc((l1+1),sizeof(real*));
@@ -2044,134 +2155,100 @@ matrix revers_partf(sequ *os, iseq *is, u_sc m, aligm a)
       rE[i]=(real*) calloc((l0+1),sizeof(real));
     }
 
+  e_beta_open = exp(BETA*m.mat[l-2][0]);
+  e_beta_extend = exp(BETA*m.mat[l-1][0]);
+  if(Egap_flag) e_beta_endgap = exp(BETA*m.endgaps);
+
   opt=a.score;
   
   s=2.0*opt/(l0+l1);
  
   sk=exp(BETA*s/2);
+#ifdef NO_SCALE
+  sk=1.0;
+#else
+  e_beta_open = e_beta_open/sk;
+  e_beta_extend = e_beta_extend/sk;
+  if(Egap_flag) e_beta_endgap = e_beta_endgap/sk;
+#endif
 
   rM[l1][l0]=1;
   /* Open in s0, => the l0st member of s0 is s0[l0-1] */
 
-  rE[0][l0-1]=rM[l1][l0]*exp(BETA*m.mat[l-2][s0[l0-1]])/sk; 
-  for(j=l0-2; j>=0; j--)
+  e_beta_open_0 = e_beta_open;
+  e_beta_extend_0 = e_beta_extend;
+  if(Egap_flag)
     {
-      /* Extent in s0 */
-      rE[0][j]=rE[0][j+1]*exp(BETA*m.mat[l-1][s0[j]])/sk;
+      e_beta_open_0 = e_beta_endgap;
+      e_beta_extend_0 = e_beta_endgap;
     }
   
-  if(Egap_flag)
+  rE[0][l0-1]=rM[l1][l0]*e_beta_open_0;
+  for(j=l0-2; j>=0; j--)
     {
-      i=l1;
-      j=l0-1;
-      rE[0][l0-1]=rM[l1][l0]*exp(BETA*m.endgaps)/sk;
-      for(j=l0-2; j>=0; j--)
-	{
-	  /* Extent in s0 */
-	  rE[0][j]=rE[0][j+1]*exp(BETA*m.endgaps)/sk;
-	}
+      rE[0][j]=rE[0][j+1]*e_beta_extend_0;
     }
   
+  rF[1][l0]=rM[l1][l0]*e_beta_open_0;
+  
   for(i=l1-1; i>=0; i--)
     {
-      for(j=l0-1; j>=0; j--)
-	{
-	  if(i==l1-1 && j==l0-1)
-	    {
-	      if(Egap_flag)
-		{
-		  rF[1][l0]=rM[l1][l0]*exp(BETA*m.endgaps)/sk;
-		  /*  printf("%d,%d rF=%.4e  ",l1-1,l0,rF[1][l0]); */ 
-		}
-	      else
-		{
-		  /* Open in s1 */
-		  rF[1][l0]=rM[l1][l0]*exp(BETA*m.mat[l-2][s1[i]])/sk;
-		}
-	    }
-	  if(i<l1-1 && j==l0-1)
-	    {
-	      if(Egap_flag)
-		{
-		  rF[1][l0]=rF[0][l0]*exp(BETA*m.endgaps)/sk;
-		  /*  printf("%d,%d rF=%.4e  ",i,l0,rF[1][l0]); */
-		}
-	      else
-		{
-		  /* Extent in s1 */
-		  rF[1][l0]=rF[0][l0]*exp(BETA*m.mat[l-1][s1[i]])/sk;  
-		}
-	    }
-
-	  if(Egap_flag && j==0 && i>0)
-	    {
-	      rF[1][j]=rF[0][j]*exp(BETA*m.endgaps);
-	      rF[1][j]+=rM[i+1][j]*exp(BETA*m.endgaps);
-	      rF[1][j]/=sk;
-	      /*  printf("%d,%d rF=%.4e  ",i,j,rF[1][j]); */
-
-	      rE[1][j]=rE[1][j+1]*exp(BETA*m.mat[l-1][s0[j]]);/* ext in s0 */
-	      /* o in s0 */  
-	      rE[1][j]+=(rM[i][j+1]+rF[1][j+1])*exp(BETA*m.mat[l-2][s0[j]]);
-	      rE[1][j]/=sk;
-	      
-	    }
-	  else if(Egap_flag && i==0 && j>0)
-	    {
-	      rE[1][j]=rE[1][j+1]*exp(BETA*m.endgaps);
-	      rE[1][j]+=(rM[i][j+1]+rF[1][j+1])*exp(BETA*m.endgaps);
-	      rE[1][j]/=sk;
+      e_beta_open_0 = e_beta_open;
+      e_beta_extend_0 = e_beta_extend;
 
-	      rF[1][j]=rF[0][j]*exp(BETA*m.mat[l-1][s1[i]]);/* ext in s1 */
-	      rF[1][j]+=rM[i+1][j]*exp(BETA*m.mat[l-2][s1[i]]);/* o in s1 */
-	      rF[1][j]/=sk;     
-	    }
-	  else if(Egap_flag && i==0 && j==0)
-	    {
-	      rF[1][j]=rF[0][j]*exp(BETA*m.endgaps);
-	      rF[1][j]+=rM[i+1][j]*exp(BETA*m.endgaps);
-	      rF[1][j]/=sk;
+      if(Egap_flag)
+        {
+          if (i == 0)
+            {
+              e_beta_open_0 = e_beta_endgap;
+              e_beta_extend_0 = e_beta_endgap;
+            }
+        }
 
-	      rE[1][j]=rE[1][j+1]*exp(BETA*m.endgaps);
-	      rE[1][j]+=(rM[i][j+1]+rF[1][j+1])*exp(BETA*m.endgaps);
-	      rE[1][j]/=sk;
-	    }
-	  else
-	    {
-	      /* rF(i,j) = ( rM(i+1,j)*exp(BETA*Open) +
-	                     rF(i+1,j)*exp(BETA*Extend) ) / sk; */
-	      rF[1][j]=rF[0][j]*exp(BETA*m.mat[l-1][s1[i]]);/* ext in s1 */
-	      rF[1][j]+=rM[i+1][j]*exp(BETA*m.mat[l-2][s1[i]]);/* o in s1 */
-	      rF[1][j]/=sk;
-	      
-	      /* rE(i,j) =( (rM(i,j+1)+rF(i,j+1))*exp(BETA*Open) +
-	                     rE(i,j+1)*exp(BETA*Extend) ) / sk; */
-	      rE[1][j]=rE[1][j+1]*exp(BETA*m.mat[l-1][s0[j]]);/* ext in s0 */
-	      /* o in s0 */
-	      rE[1][j]+=(rM[i][j+1]+rF[1][j+1])*exp(BETA*m.mat[l-2][s0[j]]);
-	      rE[1][j]/=sk;
-	    }
+      for(j=l0-1; j>=0; j--)
+	{
+          e_beta_open_1 = e_beta_open;
+          e_beta_extend_1 = e_beta_extend;
+
+          if(Egap_flag)
+            {
+              if (j == 0)
+                {
+                  e_beta_open_1 = e_beta_endgap;
+                  e_beta_extend_1 = e_beta_endgap;
+                }
+            }
+
+	  /* rE(i,j) = ( (rM(i,j+1)+rF(i,j+1))*exp(BETA*Open) +
+	                 rE(i,j+1)*exp(BETA*Extend) ) / sk; */
+#ifndef REC_F_INCL_E
+	  rE[1][j]=rM[i][j+1]*e_beta_open_0+rE[1][j+1]*e_beta_extend_0;
+#else
+	  rE[1][j]=(rM[i][j+1]+rF[1][j+1])*e_beta_open_0+rE[1][j+1]*e_beta_extend_0;
+#endif
 	  
+	  /* rF(i,j) = ( (rM(i+1,j)+rE(i+1,j))*exp(BETA*Open) +
+	                 rF(i+1,j)*exp(BETA*Extend) ) / sk; */
+#ifndef REC_E_INCL_F
+	  rF[1][j]=rM[i+1][j]*e_beta_open_1+rF[0][j]*e_beta_extend_1;
+#else
+	  rF[1][j]=(rM[i+1][j]+rE[0][j])*e_beta_open_1+rF[0][j]*e_beta_extend_1;
+#endif
+
 	  /* rM(i,j)= ( exp(BETA*match or mismatch)*
 	                (rM(i+1,j+1)+rE(i+1,j+1)+rF(i+1,j+1) ) /sk*sk; */
-	  rM[i][j]=exp(BETA*m.mat[s0[j]][s1[i]]);
-	  rM[i][j]*=(rM[i+1][j+1]+rF[0][j+1]+rE[0][j+1]);
-	  rM[i][j]/=sk*sk;
-	  
+	  rM[i][j]=(rM[i+1][j+1]+rF[0][j+1]+rE[0][j+1])*e_beta_score[s0[j]][s1[i]];
+	}
 
-	  if(j == 0)
-	    {
-	      int k;
-	      for(k=l0; k>=0; k--)
-		{
-		  rF[0][k]=rF[1][k];
-		  rF[1][k]=0;
+      swap=rE[0];
+      rE[0]=rE[1];
+      rE[1]=swap;
 
-		  rE[0][k]=rE[1][k];
-		  rE[1][k]=0;
-		}
-	    }
-	}
+      swap=rF[0];
+      rF[0]=rF[1];
+      rF[1]=swap;
+
+      rF[1][l0]=rF[0][l0]*e_beta_extend_1;
     }
   
   Zr=rM[0][0]+rE[0][0]+rF[0][0];
@@ -2239,13 +2316,19 @@ matrix partf(aligm a)
   double Z;
   double s;
   double sk;     /* scaling factor */
+  double sk_pow;
+  double e_beta_open, e_beta_open_0, e_beta_open_1;
+  double e_beta_extend, e_beta_extend_0, e_beta_extend_1;
+  double e_beta_endgap;
   real **zM;
   real **zE;
   real **zF;
   matrix pf;
   u_sc m;
+  float BETA;
 
   m=scmat;
+  BETA=m.beta;
  
  
   s0=si[0].s;
@@ -2255,6 +2338,8 @@ matrix partf(aligm a)
   l=strlen(m.monomers);
 
   /* print some infos */
+  if(verbose_flag>=0)
+    {
   printf("#parameters\n");
   printf("#T = %.2f\n",T);
   printf("#scoring matrix: %s;\n",m.name);
@@ -2264,6 +2349,13 @@ matrix partf(aligm a)
       printf("#endgap penalty: %.2f\n",m.endgaps);
     }
   printf("#\n");
+    }
+
+  e_beta_score=(real**) calloc(l,sizeof(real*));
+  for(i=0; i<l; i++)
+    {
+      e_beta_score[i]=(real*) calloc(l,sizeof(real));
+    }
 
   /* [i][j] => i runs along the rows, j runs along the columns !!!!*/
  
@@ -2292,6 +2384,7 @@ matrix partf(aligm a)
     }
   
   /* the recurrence for zE is zE(i,j)= zM(i,j-1)*exp(BETA*(-OPEN) +
+                                     + zF(i,j-1)*exp(BETA*(-OPEN) +
                                      + zE(i,j-1)*exp(BETA*(-EXT);
      one therefor never leves the current row but one needs the values
      of the previous column to calculate zF(i,j)  */
@@ -2302,11 +2395,38 @@ matrix partf(aligm a)
       zE[i]=(real*) calloc((l0+1), sizeof(real));
     }
   
+  for(i=0; i<l; i++)
+    {
+      for(j=0; j<l; j++)
+        {
+          e_beta_score[i][j] = exp(BETA*m.mat[i][j]);
+        }
+    }
+  
+  e_beta_open = exp(BETA*m.mat[l-2][0]);
+  e_beta_extend = exp(BETA*m.mat[l-1][0]);
+  if(Egap_flag) e_beta_endgap = exp(BETA*m.endgaps);
+  
   /* opt: optimale score of the alignement of the two sequences */
   opt=a.score;
   s=2.0*opt/(l0+l1);
   sk=exp(BETA*s/2);
-  
+#ifdef NO_SCALE
+  sk=1.0;
+#else
+  e_beta_open = e_beta_open/sk;
+  e_beta_extend = e_beta_extend/sk;
+  if(Egap_flag) e_beta_endgap = e_beta_endgap/sk;
+  
+  sk_pow=sk*sk;
+  for(i=0; i<l; i++)
+    {
+      for(j=0; j<l; j++)
+        {
+          e_beta_score[i][j] = e_beta_score[i][j]/sk_pow;
+        }
+    }
+#endif
   
   /* zM[0][0]=1 */
   zM[0][0]=1;
@@ -2317,111 +2437,71 @@ matrix partf(aligm a)
   /* zE[0][0]=0;
      zE[0][j]=zM[0][j-1]*exp(BETA*(-OPEN)+zE[0][j-1]*exp(BETA*(-EXT) */
 
-  i=0;
-  j=1;
-  /* zE[0][0]=0 */
-  zE[0][1]=zM[0][0]*exp(BETA*m.mat[l-2][s0[0]])/sk; /* Open in s0 */ 
+  e_beta_open_0 = e_beta_open;
+  e_beta_extend_0 = e_beta_extend;
+  if(Egap_flag)
+    {
+      e_beta_open_0 = e_beta_endgap;
+      e_beta_extend_0 = e_beta_endgap;
+    }
 
-  /* zM[0][j>0]=0 */
+  zE[0][1]=zM[0][0]*e_beta_open_0;
   for(j=2; j<=l0; j++)
     {
-      /* Extent in s0 */ 
-      zE[0][j]=zE[0][j-1]*exp(BETA*m.mat[l-1][s0[j-1]])/sk;/* Extent in s0 */
+      zE[0][j]=zE[0][j-1]*e_beta_extend_0;
     }
   
   /* initialize zF[0][0]=0;
                 zF[1][0]=zM[0][0]*exp(BETA*(-OPEN)); */
-  i=1;
-  j=0;
-  zF[1][0]=zM[0][0]*exp(BETA*m.mat[l-2][s1[0]])/sk; /* Open in s1 */
-  
-
+  zF[1][0]=zM[0][0]*e_beta_open_0;
   for(i=2; i<=l1; i++)
     {
-      zF[i][0]=zF[i-1][0]*exp(BETA*m.mat[l-1][s1[i-1]])/sk; /* Extend in s1 */
+      zF[i][0]=zF[i-1][0]*e_beta_extend_0;
     }
   
-  if(Egap_flag)
-    {
-      i=0;
-      j=1;
-      zE[0][1]=zM[0][0]*exp(BETA*m.endgaps)/sk;
-      for(j=2; j<=l0; j++)
-	{
-	  zE[0][j]=zE[0][j-1]*exp(BETA*m.endgaps)/sk;
-	}
-      i=1;
-      j=0;
-      zF[1][0]=zM[0][0]*exp(BETA*m.endgaps)/sk;
-      for(i=2; i<=l1; i++)
-	{
-	  zF[i][0]=zF[i-1][0]*exp(BETA*m.endgaps)/sk; 
-	}
-    }
   for(i=1; i<=l1; i++)
     {
+      e_beta_open_0 = e_beta_open;
+      e_beta_extend_0 = e_beta_extend;
+
+      if(Egap_flag)
+        {
+          if (i == l1)
+            {
+              e_beta_open_0 = e_beta_endgap;
+              e_beta_extend_0 = e_beta_endgap;
+            }
+        }
+
       for(j=1; j<=l0; j++)
 	{
-	  double z;
+          e_beta_open_1 = e_beta_open;
+          e_beta_extend_1 = e_beta_extend;
 	  
-	  if(Egap_flag && i == l1 && j < l0)
-	    {
-	      zE[i][j]=zE[i][j-1]*exp(BETA*m.endgaps);
-	      zE[i][j]+=zM[i][j-1]*exp(BETA*m.endgaps); 
-	      zE[i][j]/=sk;
-	      
-	      /* Extent in s1 */
-	      zF[i][j]=zF[i-1][j]*exp(BETA*m.mat[l-1][s1[i-1]]);
-	      /* Open in s1 */
-	      zF[i][j]+=(zM[i-1][j]+zE[i-1][j])*exp(BETA*m.mat[l-2][s1[i-1]]); 
-	      zF[i][j]/=sk;
-	    }
-	  else if(Egap_flag && j == l0 && i < l1)
-	    {    
-	      zF[i][j]=zF[i-1][j]*exp(BETA*m.endgaps);
-	      zF[i][j]+=(zM[i-1][j]+zE[i-1][j])*exp(BETA*m.endgaps); 
-	      zF[i][j]/=sk;
-
-	      /* Extent in s0 */
-	      zE[i][j]=zE[i][j-1]*exp(BETA*m.mat[l-1][s0[j-1]]);
-	      /* Open in s0 */
-	      zE[i][j]+=zM[i][j-1]*exp(BETA*m.mat[l-2][s0[j-1]]); 
-	      zE[i][j]/=sk;
-	    }
-	  else if(Egap_flag && j == l0 && i == l1)
-	    {
-	      zE[i][j]=zE[i][j-1]*exp(BETA*m.endgaps);
-	      zE[i][j]+=zM[i][j-1]*exp(BETA*m.endgaps); 
-	      zE[i][j]/=sk;
-
-	      zF[i][j]=zF[i-1][j]*exp(BETA*m.endgaps);
-	      zF[i][j]+=(zM[i-1][j]+zE[i-1][j])*exp(BETA*m.endgaps); 
-	      zF[i][j]/=sk;
-	      
-	    }
-	  else
-	    {
-	      /* Extent in s0 */
-	      zE[i][j]=zE[i][j-1]*exp(BETA*m.mat[l-1][s0[j-1]]);
-	      /* Open in s0 */
-	      zE[i][j]+=zM[i][j-1]*exp(BETA*m.mat[l-2][s0[j-1]]); 
-	      zE[i][j]/=sk;
-	  
-	      /* Extent in s1 */
-	      zF[i][j]=zF[i-1][j]*exp(BETA*m.mat[l-1][s1[i-1]]);
-	      /* Open in s1 */
-	      zF[i][j]+=(zM[i-1][j]+zE[i-1][j])*exp(BETA*m.mat[l-2][s1[i-1]]); 
-	      zF[i][j]/=sk;
-	    }
-
-	  z=0;
-	  z=(m.mat[s0[j-1]][s1[i-1]]);  
-	  zM[i][j]=exp(BETA*z)*(zM[i-1][j-1]+zE[i-1][j-1]+zF[i-1][j-1]);
-	  zM[i][j]/=sk*sk;
+          if(Egap_flag)
+            {
+              if (j == l0)
+                {
+                  e_beta_open_1 = e_beta_endgap;
+                  e_beta_extend_1 = e_beta_endgap;
+                }
+            }
+
+#ifndef REC_E_INCL_F
+	  zE[i][j]=zM[i][j-1]*e_beta_open_0+zE[i][j-1]*e_beta_extend_0;
+#else
+	  zE[i][j]=(zM[i][j-1]+zF[i][j-1])*e_beta_open_0+zE[i][j-1]*e_beta_extend_0;
+#endif
+#ifndef REC_F_INCL_E
+	  zF[i][j]=zM[i-1][j]*e_beta_open_1+zF[i-1][j]*e_beta_extend_1;
+#else
+	  zF[i][j]=(zM[i-1][j]+zE[i-1][j])*e_beta_open_1+zF[i-1][j]*e_beta_extend_1;
+#endif
+	  zM[i][j]=(zM[i-1][j-1]+zE[i-1][j-1]+zF[i-1][j-1])*e_beta_score[s0[j-1]][s1[i-1]];
 	}
     }
 
-  Z=zM[i-1][j-1]+zF[i-1][j-1]+zE[i-1][j-1]; 
+  Z=zM[l1][l0]+zF[l1][l0]+zE[l1][l0]; 
   zM[0][0]=Z;
   
  /*  printf("Zz=%f\n",Z); */
@@ -2484,26 +2564,21 @@ void print_P(sequ *s, real **matr)
   int la = strlen(s[0].seq);
   int lb = strlen(s[1].seq);
   
-   printf("\n");
+   printf("\n ");
    for(i=1;i<=la;i++)
      {
-       printf("  %8c",s[0].seq[i-1]);
+       printf("   %8c",s[0].seq[i-1]);
      }
-   printf("\n");
+   printf("\n\n");
    for(i=1;i<=lb;i++)
      {
        printf("%c",s[1].seq[i-1]);
        for(j=1;j<=la;j++)
 	 {
-	   printf("  %.2e",matr[i][j]);
-       
-	   if(j==la){
-	     printf("\n\n");
-	   }
+	   printf("   %.6f",matr[i][j]);
 	 }
-     }   
-      
-   printf("\n\n");
+       printf("\n\n");
+     }
 }
 /*-----------------------------------------------------------------------*/
 
@@ -2527,9 +2602,11 @@ aligm stoch_btr(matrix pz, aligm a)
   int opt_l;
   double s_p;
   /*  two_f P_P; */ 
+  float BETA;
 
   
   m=scmat;
+  BETA=m.beta;
 
   opt_l=strlen(a.a)+20;
 
@@ -2543,6 +2620,9 @@ aligm stoch_btr(matrix pz, aligm a)
   opt=a.score;
   s=2.0*opt/(l0+l1);
   sk=exp(BETA*s/2);
+#ifdef NO_SCALE
+  sk=1.0;
+#endif
  
   Eg = Egap_flag;
 
@@ -2551,6 +2631,8 @@ aligm stoch_btr(matrix pz, aligm a)
   
   if(stochswi == 0)
     {
+      if(verbose_flag>=0)
+        {
       double tmp;
       double prob_o; /*  probability of the (or better an) optimal alignment */
 
@@ -2604,6 +2686,7 @@ aligm stoch_btr(matrix pz, aligm a)
       prob_o=exp(tmp) /pZ;
       printf("%.2e",prob_o);
       printf("\n");
+        }
   
       stochswi=1;
     }
@@ -2707,13 +2790,21 @@ aligm stoch_btr(matrix pz, aligm a)
 		{
 		  x = M[i][j]*exp(BETA*m.endgaps) / Zx;
 		  y = E[i][j]*exp(BETA*m.endgaps) / Zx;
+#ifndef REC_E_INCL_F
 		  z=0.0;
+#else
+		  z = F[i][j]*exp(BETA*m.endgaps) / Zx;
+#endif
 		}
 	      else
 		{
 		  x = M[i][j]*exp(BETA*m.mat[l-2][s1[i-1]]) / Zx;/* Open */
 		  y = E[i][j]*exp(BETA*m.mat[l-1][s1[i-1]]) / Zx;/* Ext */
+#ifndef REC_E_INCL_F
 		  z=0.0;
+#else
+		  z = F[i][j]*exp(BETA*m.mat[l-2][s1[j-1]]) / Zx;/* Open */
+#endif
 		}
 	    }
 	  
@@ -2742,13 +2833,21 @@ aligm stoch_btr(matrix pz, aligm a)
 	      if(Eg && j == l0)
 		{
 		  x=M[i][j]*exp(BETA*m.endgaps) / Zx;
+#ifndef REC_F_INCL_E
+		  y=0.0;
+#else
 		  y=E[i][j]*exp(BETA*m.endgaps) / Zx;
+#endif
 		  z=F[i][j]*exp(BETA*m.endgaps) / Zx;
 		}
 	      else
 		{
 		  x=M[i][j]*exp(BETA*m.mat[l-2][s0[j-1]]) / Zx;/* Open */
+#ifndef REC_F_INCL_E
+		  y=0.0;
+#else
 		  y=E[i][j]*exp(BETA*m.mat[l-2][s0[j-1]]) / Zx;/* Open */
+#endif
 		  z=F[i][j]*exp(BETA*m.mat[l-1][s0[j-1]]) / Zx;/* Extend */
 		}
 	    }
diff --git a/probA/pfgoto.h b/probA/pfgoto.h
index 581b879..b303180 100644
--- a/probA/pfgoto.h
+++ b/probA/pfgoto.h
@@ -15,7 +15,9 @@
 #define _PFGOTO_H_
 
 #define GAP '-'
-#define real double
+/* This define conflicts with Cython */
+/* #define real double */
+typedef double real;
 
 /* definitions essential for matrices */
 #define LN10 2.3025850930
@@ -40,6 +42,8 @@ extern int typ_flag;     /* Flag set by `-DNA'=1  or `-prot'=0
 extern int PS_flag;      /* Flag set by `-PS', default is 1 =>
 			    postscript output */
 
+extern int Ogap_flag;
+extern int Xgap_flag;
 extern int Egap_flag;    /* Flag set by `-endgaps', the default value of
 			    endgaps is 0, but can be modified by the user */
 
@@ -59,6 +63,8 @@ extern int dist_flag;    /* Flag set by `-pam', default is -1,
 /* essential global variables */
 extern float BETA;       /* default value of BETA */
 
+extern float OPENGAP;
+extern float EXTENDGAP;
 extern float ENDGAP;     /* default value for endgaps is set to 0 */
 
 extern char MAT_SER[20]; /* variable stores the selected matrix series */
@@ -82,6 +88,8 @@ extern char TRACK[30];   /* stores the filename containing the alignment
 /*char *track;              stores the alignment encoded as one string of
 			     symbols; option`-calc_s' */
 
+extern float CUT;        /* stores the cutoff value for sparse output */
+
 /* for options.c */
 extern struct option long_options[];
 extern int option_index; /* getopt_long stores the option index here. */
@@ -193,6 +201,7 @@ typedef struct{
 extern score_m gonnet_init; /* matrix for the initial protein alignment */
 extern score_m dnamt;       /* matrix for nucleic acid alignment */
 
+extern u_sc scmat;
 
 
 /* function doing a global pairwise alignment */
